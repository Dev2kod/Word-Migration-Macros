Option Explicit

' ==========================================================
' SIMPLIFIED TEMPLATE FILLING MACRO
' ==========================================================
' Purpose: Extract title and document number from source header,
'          create new file from template, fill placeholders
' Changes from original:
'   1. Title extracted from header (center, below company name)
'   2. Only extracts DOC_Number and TITLE
'   3. Creates new file (doesn't modify template)
'   4. User selects output folder and filename
'   5. All remaining placeholders filled as blank
' ==========================================================

Sub FillTemplate_SimplifiedVersion()

    Dim srcPath As String, templatePath As String, outputPath As String
    Dim srcDoc As Document, tplDoc As Document, newDoc As Document
    Dim data As Object              ' Dictionary: key -> value
    Dim fs As Object
    Dim outputFolder As String, outputFileName As String

    Set data = CreateObject("Scripting.Dictionary")
    Set fs = CreateObject("Scripting.FileSystemObject")

    ' -----------------------------------------
    ' Pick Source Document
    ' -----------------------------------------
    With Application.FileDialog(msoFileDialogFilePicker)
        .Title = "Select SOURCE Word document (to extract title and doc number from)"
        .Filters.Clear
        .Filters.Add "Word Documents", "*.docx;*.doc"
        If .Show <> -1 Then Exit Sub
        srcPath = .SelectedItems(1)
    End With

    ' -----------------------------------------
    ' Pick Template Document
    ' -----------------------------------------
    With Application.FileDialog(msoFileDialogFilePicker)
        .Title = "Select TEMPLATE Word document (with {{placeholders}})"
        .Filters.Clear
        .Filters.Add "Word Documents", "*.docx;*.doc"
        If .Show <> -1 Then Exit Sub
        templatePath = .SelectedItems(1)
    End With

    ' -----------------------------------------
    ' Select Output Folder
    ' -----------------------------------------
    With Application.FileDialog(msoFileDialogFolderPicker)
        .Title = "Select OUTPUT folder to save the filled document"
        If .Show <> -1 Then Exit Sub
        outputFolder = .SelectedItems(1)
    End With

    ' -----------------------------------------
    ' Prompt for Output File Name
    ' -----------------------------------------
    outputFileName = InputBox( _
        "Enter the output file name (without extension):" & vbCrLf & vbCrLf & _
        "The file will be saved as .docx", _
        "Output File Name", _
        "Filled_Document")
    
    If outputFileName = "" Then
        MsgBox "Output file name cannot be empty. Operation cancelled.", vbExclamation
        Exit Sub
    End If
    
    ' Remove .docx extension if user added it
    If LCase(Right(outputFileName, 5)) = ".docx" Then
        outputFileName = Left(outputFileName, Len(outputFileName) - 5)
    End If
    
    ' Build full output path
    outputPath = outputFolder & Application.PathSeparator & outputFileName & ".docx"
    
    ' Check if file already exists
    If fs.FileExists(outputPath) Then
        Dim overwrite As VbMsgBoxResult
        overwrite = MsgBox("File already exists:" & vbCrLf & outputPath & vbCrLf & vbCrLf & _
                          "Do you want to overwrite it?", vbYesNo + vbQuestion, "File Exists")
        If overwrite = vbNo Then Exit Sub
    End If

    ' -----------------------------------------
    ' Open source and extract data
    ' -----------------------------------------
    Set srcDoc = Documents.Open(FileName:=srcPath, ReadOnly:=True, Visible:=False)
    
    ' Extract title and document number from header
    Extract_TitleAndDocNumber_FromHeader srcDoc, data
    
    srcDoc.Close SaveChanges:=False

    ' -----------------------------------------
    ' Create new document from template
    ' -----------------------------------------
    Set tplDoc = Documents.Open(templatePath, AddToRecentFiles:=False, ReadOnly:=True, Visible:=False)
    
    ' Create a copy - don't modify the original template
    Set newDoc = Documents.Add(Template:=tplDoc.FullName, Visible:=False)
    tplDoc.Close SaveChanges:=False
    
    ' -----------------------------------------
    ' Replace placeholders in the new document
    ' -----------------------------------------
    
    ' 1) Replace the placeholders we have data for
    Dim k As Variant, ph As String
    For Each k In data.Keys
        ph = "{{" & CStr(k) & "}}"
        ReplaceInAllStories newDoc, ph, CStr(data(k))
        ReplaceInAllShapes newDoc, ph, CStr(data(k))
        ReplaceInAllHeaderFooterShapes newDoc, ph, CStr(data(k))
    Next k

    ' 2) Clear all remaining placeholders (fill with blank)
    Dim placeholders As Collection, i As Long, token As String
    Set placeholders = CollectPlaceholders(newDoc)
    
    For i = 1 To placeholders.Count
        token = placeholders(i)
        If Not data.Exists(token) Then
            ph = "{{" & token & "}}"
            ReplaceInAllStories newDoc, ph, ""
            ReplaceInAllShapes newDoc, ph, ""
            ReplaceInAllHeaderFooterShapes newDoc, ph, ""
        End If
    Next i

    ' -----------------------------------------
    ' Save the new document to output path
    ' -----------------------------------------
    newDoc.SaveAs2 outputPath, wdFormatXMLDocument
    newDoc.Close SaveChanges:=False
    
    MsgBox "Template filled successfully!" & vbCrLf & vbCrLf & _
           "Output file: " & vbCrLf & outputPath, vbInformation, "Success"

End Sub


' ==========================================================
' DATA EXTRACTION - HEADER ONLY
' ==========================================================
Private Sub Extract_TitleAndDocNumber_FromHeader(ByVal doc As Document, ByRef data As Object)
    '
    ' Extract Title and Document Number from the header section
    ' Title is in center, below "Tata Consulting Engineers"
    ' Document number is a pattern like XXX-XXX-XXXX or similar
    '
    Dim headerText As String
    Dim headerLines() As String
    Dim i As Long, line As String
    Dim docNumber As String, title As String
    Dim foundCompanyName As Boolean
    Dim titleLines As String
    
    ' Get the header text from first section
    On Error Resume Next
    headerText = doc.Sections(1).Headers(wdHeaderFooterPrimary).Range.Text
    On Error GoTo 0
    
    If headerText = "" Then Exit Sub
    
    ' Split into lines
    headerLines = Split(headerText, vbCr)
    foundCompanyName = False
    titleLines = ""
    
    For i = 0 To UBound(headerLines)
        line = Trim(headerLines(i))
        
        If line <> "" Then
            ' Look for document number pattern (alphanumeric with hyphens/dots)
            ' Examples: TCE.1234.5678, ABC-DEF-1234, etc.
            If docNumber = "" Then
                If IsDocumentNumber(line) Then
                    docNumber = line
                End If
            End If
            
            ' Look for company name
            If InStr(1, UCase(line), "TATA CONSULTING ENGINEERS", vbTextCompare) > 0 Then
                foundCompanyName = True
            ElseIf foundCompanyName Then
                ' After company name, collect lines that look like a title
                ' Skip lines that look like metadata (FILE NAME, DOCUMENT VALID, etc.)
                If InStr(1, UCase(line), "FILE NAME") = 0 And _
                   InStr(1, UCase(line), "DOCUMENT VALID") = 0 And _
                   InStr(1, UCase(line), "REVISION") = 0 And _
                   Len(line) > 3 Then  ' Skip very short lines
                    
                    If titleLines <> "" Then
                        titleLines = titleLines & " " & line
                    Else
                        titleLines = line
                    End If
                End If
            End If
        End If
    Next i
    
    ' Clean up title - remove extra spaces
    title = CleanText(titleLines)
    
    ' Store in data dictionary
    data("TITLE") = Nz(title)
    data("DOC_Number") = Nz(docNumber)
    
End Sub

Private Function IsDocumentNumber(ByVal text As String) As Boolean
    '
    ' Check if a line looks like a document number
    ' Pattern: Contains letters/numbers with separators (., -, /)
    ' Examples: TCE.1234.5678, ABC-DEF-1234, DOC/2024/001
    '
    Dim cleanText As String
    Dim hasLetters As Boolean, hasNumbers As Boolean, hasSeparators As Boolean
    Dim i As Long, ch As String
    
    cleanText = Trim(text)
    
    ' Must be between 5 and 50 characters
    If Len(cleanText) < 5 Or Len(cleanText) > 50 Then
        IsDocumentNumber = False
        Exit Function
    End If
    
    ' Check for presence of letters, numbers, and separators
    For i = 1 To Len(cleanText)
        ch = Mid(cleanText, i, 1)
        If ch Like "[A-Za-z]" Then hasLetters = True
        If ch Like "[0-9]" Then hasNumbers = True
        If ch = "." Or ch = "-" Or ch = "/" Or ch = "_" Then hasSeparators = True
    Next i
    
    ' Document number should have both letters and numbers, plus separators
    ' OR just numbers with separators (for numeric doc IDs)
    If (hasLetters And hasNumbers And hasSeparators) Or _
       (hasNumbers And hasSeparators) Then
        IsDocumentNumber = True
    Else
        IsDocumentNumber = False
    End If
    
End Function

Private Function CleanText(ByVal text As String) As String
    '
    ' Remove extra spaces, trim, clean up text
    '
    Dim result As String
    result = Trim(text)
    
    ' Replace multiple spaces with single space
    Do While InStr(result, "  ") > 0
        result = Replace(result, "  ", " ")
    Loop
    
    CleanText = result
End Function


' ==========================================================
' FIND/REPLACE UTILITIES (all stories & all shapes)
' ==========================================================
Private Sub ReplaceInAllStories(ByVal doc As Document, ByVal findText As String, ByVal replText As String)
    Dim s As Range
    Dim st As Long
    
    ' Loop through all story types (1 to 17 covers all standard story ranges)
    For st = wdMainTextStory To wdEvenPagesFooterStory
        On Error Resume Next
        Set s = doc.StoryRanges(st)
        If Not s Is Nothing Then
            Do
                FindReplaceOnRange s, findText, replText
                Set s = s.NextStoryRange
            Loop Until s Is Nothing
        End If
        On Error GoTo 0
    Next st
End Sub

Private Sub FindReplaceOnRange(ByVal rng As Range, ByVal findText As String, ByVal replText As String)
    With rng.Find
        .ClearFormatting
        .Replacement.ClearFormatting
        .Text = findText
        .Replacement.Text = replText
        .Forward = True
        .Wrap = wdFindStop
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .Execute Replace:=wdReplaceAll
    End With
End Sub

Private Sub ReplaceInAllShapes(ByVal doc As Document, ByVal findText As String, ByVal replText As String)
    Dim shp As Shape
    For Each shp In doc.Shapes
        ReplaceInShapeRecursive shp, findText, replText
    Next shp
End Sub

Private Sub ReplaceInAllHeaderFooterShapes(ByVal doc As Document, ByVal findText As String, ByVal replText As String)
    Dim sec As Section, hdr As HeaderFooter, ftr As HeaderFooter, shp As Shape
    
    For Each sec In doc.Sections
        For Each hdr In sec.Headers
            For Each shp In hdr.Shapes
                ReplaceInShapeRecursive shp, findText, replText
            Next shp
        Next hdr
        
        For Each ftr In sec.Footers
            For Each shp In ftr.Shapes
                ReplaceInShapeRecursive shp, findText, replText
            Next shp
        Next ftr
    Next sec
End Sub

Private Sub ReplaceInShapeRecursive(ByVal shp As Shape, ByVal findText As String, ByVal replText As String)
    Dim g As Shape
    On Error Resume Next
    
    If shp.Type = msoGroup Then
        For Each g In shp.GroupItems
            ReplaceInShapeRecursive g, findText, replText
        Next g
    Else
        If shp.TextFrame.HasText Then
            FindReplaceOnRange shp.TextFrame.TextRange, findText, replText
        End If
    End If
    
    On Error GoTo 0
End Sub


' ==========================================================
' PLACEHOLDER COLLECTOR
' ==========================================================
Private Function CollectPlaceholders(doc As Document) As Collection
    '
    ' Find all {{placeholder}} patterns in the document
    '
    Dim col As New Collection
    Dim seen As Object: Set seen = CreateObject("Scripting.Dictionary")

    ' Search in all story ranges (main text, headers, footers)
    Dim st As Long, r As Range
    For st = wdMainTextStory To wdEvenPagesFooterStory
        On Error Resume Next
        Set r = doc.StoryRanges(st)
        Do While Not r Is Nothing
            AddFoundPlaceholders r.Text, col, seen
            Set r = r.NextStoryRange
        Loop
        On Error GoTo 0
    Next st

    ' Search in shapes
    Dim shp As Shape
    For Each shp In doc.Shapes
        If shp.TextFrame.HasText Then
            AddFoundPlaceholders shp.TextFrame.TextRange.Text, col, seen
        End If
    Next shp

    ' Search in header/footer shapes
    Dim sec As Section, hdr As HeaderFooter, ftr As HeaderFooter
    For Each sec In doc.Sections
        For Each hdr In sec.Headers
            For Each shp In hdr.Shapes
                If shp.TextFrame.HasText Then
                    AddFoundPlaceholders shp.TextFrame.TextRange.Text, col, seen
                End If
            Next shp
        Next hdr
        
        For Each ftr In sec.Footers
            For Each shp In ftr.Shapes
                If shp.TextFrame.HasText Then
                    AddFoundPlaceholders shp.TextFrame.TextRange.Text, col, seen
                End If
            Next shp
        Next ftr
    Next sec

    Set CollectPlaceholders = col
End Function

Private Sub AddFoundPlaceholders(ByVal s As String, ByRef col As Collection, ByVal seen As Object)
    '
    ' Parse text for {{placeholder}} patterns and add unique ones to collection
    '
    Dim i As Long, j As Long, token As String
    
    i = 1
    Do
        i = InStr(i, s, "{{")
        If i = 0 Then Exit Do
        
        j = InStr(i + 2, s, "}}")
        If j = 0 Then Exit Do
        
        token = Mid$(s, i + 2, j - (i + 2))
        
        If Len(token) > 0 Then
            If Not seen.Exists(token) Then
                seen(token) = True
                col.Add token
            End If
        End If
        
        i = j + 2
    Loop
End Sub


' ==========================================================
' Helper Functions
' ==========================================================
Private Function Nz(ByVal v As Variant, Optional ByVal fallback As String = "") As String
    '
    ' Null-safe string conversion
    '
    If IsNull(v) Then
        Nz = fallback
    ElseIf IsEmpty(v) Then
        Nz = fallback
    ElseIf VarType(v) = vbString Then
        If Trim(v) = "" Then
            Nz = fallback
        Else
            Nz = v
        End If
    Else
        Nz = CStr(v)
    End If
End Function
